
Lab_3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000d0  00800100  00000460  000004f4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000460  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000b  008001d0  008001d0  000005c4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000005c4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000005f4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000080  00000000  00000000  00000638  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000ec6  00000000  00000000  000006b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000009c9  00000000  00000000  0000157e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000709  00000000  00000000  00001f47  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000c8  00000000  00000000  00002650  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000004d6  00000000  00000000  00002718  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000000f7  00000000  00000000  00002bee  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000050  00000000  00000000  00002ce5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__ctors_end>
   4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
   8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
   c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  10:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  14:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  18:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  1c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  20:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  24:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  28:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  2c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  30:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  34:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  38:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  3c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  40:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  44:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  48:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  4c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  50:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  54:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  58:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  5c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  60:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  64:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  68:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  6c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  70:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  74:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  78:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  7c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  80:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  84:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  88:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  8c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  90:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  94:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  98:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  9c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a0:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  ac:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  b0:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>

000000b4 <__ctors_end>:
  b4:	11 24       	eor	r1, r1
  b6:	1f be       	out	0x3f, r1	; 63
  b8:	cf ef       	ldi	r28, 0xFF	; 255
  ba:	d8 e0       	ldi	r29, 0x08	; 8
  bc:	de bf       	out	0x3e, r29	; 62
  be:	cd bf       	out	0x3d, r28	; 61

000000c0 <__do_copy_data>:
  c0:	11 e0       	ldi	r17, 0x01	; 1
  c2:	a0 e0       	ldi	r26, 0x00	; 0
  c4:	b1 e0       	ldi	r27, 0x01	; 1
  c6:	e0 e6       	ldi	r30, 0x60	; 96
  c8:	f4 e0       	ldi	r31, 0x04	; 4
  ca:	02 c0       	rjmp	.+4      	; 0xd0 <UDR0+0xa>
  cc:	05 90       	lpm	r0, Z+
  ce:	0d 92       	st	X+, r0
  d0:	a0 3d       	cpi	r26, 0xD0	; 208
  d2:	b1 07       	cpc	r27, r17
  d4:	d9 f7       	brne	.-10     	; 0xcc <UDR0+0x6>

000000d6 <__do_clear_bss>:
  d6:	21 e0       	ldi	r18, 0x01	; 1
  d8:	a0 ed       	ldi	r26, 0xD0	; 208
  da:	b1 e0       	ldi	r27, 0x01	; 1
  dc:	01 c0       	rjmp	.+2      	; 0xe0 <.do_clear_bss_start>

000000de <.do_clear_bss_loop>:
  de:	1d 92       	st	X+, r1

000000e0 <.do_clear_bss_start>:
  e0:	ab 3d       	cpi	r26, 0xDB	; 219
  e2:	b2 07       	cpc	r27, r18
  e4:	e1 f7       	brne	.-8      	; 0xde <.do_clear_bss_loop>
  e6:	0e 94 ff 01 	call	0x3fe	; 0x3fe <main>
  ea:	0c 94 2e 02 	jmp	0x45c	; 0x45c <_exit>

000000ee <__bad_interrupt>:
  ee:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000f2 <Mega328P_Init>:
.set	temp,0				//student comment here

.section ".text"			//equivalent to CSEG
.global Mega328P_Init
Mega328P_Init:
		ldi	r16,0x07		;PB0(R*W),PB1(RS),PB2(E) as fixed outputs
  f2:	07 e0       	ldi	r16, 0x07	; 7
		out	DDRB,r16		//student comment here
  f4:	04 b9       	out	0x04, r16	; 4
		ldi	r16,0			//student comment here
  f6:	00 e0       	ldi	r16, 0x00	; 0
		out	PORTB,r16		//student comment here
  f8:	05 b9       	out	0x05, r16	; 5
		out	U2X0,r16		;initialize UART, 8bits, no parity, 1 stop, 9600
  fa:	01 b9       	out	0x01, r16	; 1
		ldi	r17,0x0			//student comment here
  fc:	10 e0       	ldi	r17, 0x00	; 0
		ldi	r16,0x67		//student comment here
  fe:	07 e6       	ldi	r16, 0x67	; 103
		sts	UBRR0H,r17		//student comment here
 100:	10 93 c5 00 	sts	0x00C5, r17	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		sts	UBRR0L,r16		//student comment here
 104:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
		ldi	r16,24			//student comment here
 108:	08 e1       	ldi	r16, 0x18	; 24
		sts	UCSR0B,r16		//student comment here
 10a:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		ldi	r16,6			//student comment here
 10e:	06 e0       	ldi	r16, 0x06	; 6
		sts	UCSR0C,r16		//student comment here
 110:	00 93 c2 00 	sts	0x00C2, r16	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		ldi r16,0x87		//initialize ADC
 114:	07 e8       	ldi	r16, 0x87	; 135
		sts	ADCSRA,r16		//student comment here
 116:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		ldi r16,0x40		//student comment here
 11a:	00 e4       	ldi	r16, 0x40	; 64
		sts ADMUX,r16		//student comment here
 11c:	00 93 7c 00 	sts	0x007C, r16	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
		ldi r16,0			//student comment here
 120:	00 e0       	ldi	r16, 0x00	; 0
		sts ADCSRB,r16		//student comment here
 122:	00 93 7b 00 	sts	0x007B, r16	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
		ldi r16,0xFE		//student comment here
 126:	0e ef       	ldi	r16, 0xFE	; 254
		sts DIDR0,r16		//student comment here
 128:	00 93 7e 00 	sts	0x007E, r16	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
		ldi r16,0xFF		//student comment here
 12c:	0f ef       	ldi	r16, 0xFF	; 255
		sts DIDR1,r16		//student comment here
 12e:	00 93 7f 00 	sts	0x007F, r16	; 0x80007f <__TEXT_REGION_LENGTH__+0x7e007f>
		ret					//student comment here
 132:	08 95       	ret

00000134 <LCD_Write_Command>:
	
.global LCD_Write_Command
LCD_Write_Command:
	call	UART_Off		//student comment here
 134:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>
	ldi		r16,0xFF		;PD0 - PD7 as outputs
 138:	0f ef       	ldi	r16, 0xFF	; 255
	out		DDRD,r16		//student comment here
 13a:	0a b9       	out	0x0a, r16	; 10
	lds		r16,DATA		//student comment here
 13c:	00 91 d0 01 	lds	r16, 0x01D0	; 0x8001d0 <__data_end>
	out		PORTD,r16		//student comment here
 140:	0b b9       	out	0x0b, r16	; 11
	ldi		r16,4			//student comment here
 142:	04 e0       	ldi	r16, 0x04	; 4
	out		PORTB,r16		//student comment here
 144:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 146:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
	ldi		r16,0			//student comment here
 14a:	00 e0       	ldi	r16, 0x00	; 0
	out		PORTB,r16		//student comment here
 14c:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 14e:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
	call	UART_On			//student comment here
 152:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>
	ret						//student comment here
 156:	08 95       	ret

00000158 <LCD_Delay>:

LCD_Delay:
	ldi		r16,0xFA		//student comment here
 158:	0a ef       	ldi	r16, 0xFA	; 250

0000015a <D0>:
D0:	ldi		r17,0xFF		//student comment here
 15a:	1f ef       	ldi	r17, 0xFF	; 255

0000015c <D1>:
D1:	dec		r17				//student comment here
 15c:	1a 95       	dec	r17
	brne	D1				//student comment here
 15e:	f1 f7       	brne	.-4      	; 0x15c <D1>
	dec		r16				//student comment here
 160:	0a 95       	dec	r16
	brne	D0				//student comment here
 162:	d9 f7       	brne	.-10     	; 0x15a <D0>
	ret						//student comment here
 164:	08 95       	ret

00000166 <LCD_Write_Data>:

.global LCD_Write_Data
LCD_Write_Data:
	call	UART_Off		//turn off communication
 166:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>
	ldi		r16,0xFF		//student comment here
 16a:	0f ef       	ldi	r16, 0xFF	; 255
	out		DDRD,r16		//student comment here
 16c:	0a b9       	out	0x0a, r16	; 10
	lds		r16,DATA		//student comment here
 16e:	00 91 d0 01 	lds	r16, 0x01D0	; 0x8001d0 <__data_end>
	out		PORTD,r16		//student comment here
 172:	0b b9       	out	0x0b, r16	; 11
	ldi		r16,6			//student comment here
 174:	06 e0       	ldi	r16, 0x06	; 6
	out		PORTB,r16		//student comment here
 176:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 178:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
	ldi		r16,0			//student comment here
 17c:	00 e0       	ldi	r16, 0x00	; 0
	out		PORTB,r16		//student comment here
 17e:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 180:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
	call	UART_On			//turn on the communication
 184:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>
	ret						//student comment here
 188:	08 95       	ret

0000018a <LCD_Read_Data>:

.global LCD_Read_Data
LCD_Read_Data:
	call	UART_Off		//student comment here
 18a:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>
	ldi		r16,0x00		//student comment here
 18e:	00 e0       	ldi	r16, 0x00	; 0
	out		DDRD,r16		//student comment here
 190:	0a b9       	out	0x0a, r16	; 10
	out		PORTB,4			//student comment here
 192:	45 b8       	out	0x05, r4	; 5
	in		r16,PORTD		//student comment here
 194:	0b b1       	in	r16, 0x0b	; 11
	sts		DATA,r16		//student comment here
 196:	00 93 d0 01 	sts	0x01D0, r16	; 0x8001d0 <__data_end>
	out		PORTB,0			//student comment here
 19a:	05 b8       	out	0x05, r0	; 5
	call	UART_On			//student comment here
 19c:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>
	ret						//student comment here
 1a0:	08 95       	ret

000001a2 <UART_On>:

.global UART_On
UART_On:
	ldi		r16,2				//student comment here
 1a2:	02 e0       	ldi	r16, 0x02	; 2
	out		DDRD,r16			//student comment here
 1a4:	0a b9       	out	0x0a, r16	; 10
	ldi		r16,24				//student comment here
 1a6:	08 e1       	ldi	r16, 0x18	; 24
	sts		UCSR0B,r16			//student comment here
 1a8:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	ret							//student comment here
 1ac:	08 95       	ret

000001ae <UART_Off>:

.global UART_Off
UART_Off:
	ldi	r16,0					//student comment here
 1ae:	00 e0       	ldi	r16, 0x00	; 0
	sts UCSR0B,r16				//student comment here
 1b0:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	ret							//student comment here
 1b4:	08 95       	ret

000001b6 <UART_Clear>:

.global UART_Clear
UART_Clear:
	lds		r16,UCSR0A			//student comment here
 1b6:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	r16,RXC0			//student comment here
 1ba:	07 ff       	sbrs	r16, 7
	ret							//student comment here
 1bc:	08 95       	ret
	lds		r16,UDR0			//student comment here
 1be:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	rjmp	UART_Clear			//student comment here
 1c2:	f9 cf       	rjmp	.-14     	; 0x1b6 <UART_Clear>

000001c4 <UART_Get>:

.global UART_Get
UART_Get:
	lds		r16,UCSR0A			//student comment here
 1c4:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	r16,RXC0			//student comment here
 1c8:	07 ff       	sbrs	r16, 7
	rjmp	UART_Get			//student comment here
 1ca:	fc cf       	rjmp	.-8      	; 0x1c4 <UART_Get>
	lds		r16,UDR0			//student comment here
 1cc:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	sts		ASCII,r16			//student comment here
 1d0:	00 93 d2 01 	sts	0x01D2, r16	; 0x8001d2 <ASCII>
	ret							//student comment here
 1d4:	08 95       	ret

000001d6 <UART_Put>:

.global UART_Put
UART_Put:
	lds		r17,UCSR0A			//student comment here
 1d6:	10 91 c0 00 	lds	r17, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	r17,UDRE0			//student comment here
 1da:	15 ff       	sbrs	r17, 5
	rjmp	UART_Put			//student comment here
 1dc:	fc cf       	rjmp	.-8      	; 0x1d6 <UART_Put>
	lds		r16,ASCII			//student comment here
 1de:	00 91 d2 01 	lds	r16, 0x01D2	; 0x8001d2 <ASCII>
	sts		UDR0,r16			//student comment here
 1e2:	00 93 c6 00 	sts	0x00C6, r16	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	ret							//student comment here
 1e6:	08 95       	ret

000001e8 <ADC_Get>:

.global ADC_Get
ADC_Get:
		ldi		r16,0xC7			//student comment here
 1e8:	07 ec       	ldi	r16, 0xC7	; 199
		sts		ADCSRA,r16			//student comment here
 1ea:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>

000001ee <A2V1>:
A2V1:	lds		r16,ADCSRA			//student comment here
 1ee:	00 91 7a 00 	lds	r16, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		sbrc	r16,ADSC			//student comment here
 1f2:	06 fd       	sbrc	r16, 6
		rjmp 	A2V1				//student comment here
 1f4:	fc cf       	rjmp	.-8      	; 0x1ee <A2V1>
		lds		r16,ADCL			//student comment here
 1f6:	00 91 78 00 	lds	r16, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
		sts		LADC,r16			//student comment here
 1fa:	00 93 d8 01 	sts	0x01D8, r16	; 0x8001d8 <LADC>
		lds		r16,ADCH			//student comment here
 1fe:	00 91 79 00 	lds	r16, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
		sts		HADC,r16			//student comment here
 202:	00 93 d1 01 	sts	0x01D1, r16	; 0x8001d1 <HADC>
		ret							//student comment here
 206:	08 95       	ret

00000208 <EEPROM_Write>:

.global EEPROM_Write
EEPROM_Write:      
		sbic    EECR,EEPE
 208:	f9 99       	sbic	0x1f, 1	; 31
		rjmp    EEPROM_Write		; Wait for completion of previous write
 20a:	fe cf       	rjmp	.-4      	; 0x208 <EEPROM_Write>
		ldi		r18,0x00			; Set up address (r18:r17) in address register
 20c:	20 e0       	ldi	r18, 0x00	; 0
		ldi		r17,0x05 
 20e:	15 e0       	ldi	r17, 0x05	; 5
		ldi		r16,'F'				; Set up data in r16    
 210:	06 e4       	ldi	r16, 0x46	; 70
		out     EEARH, r18      
 212:	22 bd       	out	0x22, r18	; 34
		out     EEARL, r17			      
 214:	11 bd       	out	0x21, r17	; 33
		out     EEDR,r16			; Write data (r16) to Data Register  
 216:	00 bd       	out	0x20, r16	; 32
		sbi     EECR,EEMPE			; Write logical one to EEMPE
 218:	fa 9a       	sbi	0x1f, 2	; 31
		sbi     EECR,EEPE			; Start eeprom write by setting EEPE
 21a:	f9 9a       	sbi	0x1f, 1	; 31
		ret 
 21c:	08 95       	ret

0000021e <EEPROM_Read>:

.global EEPROM_Read
EEPROM_Read:					    
		sbic    EECR,EEPE    
 21e:	f9 99       	sbic	0x1f, 1	; 31
		rjmp    EEPROM_Read		; Wait for completion of previous write
 220:	fe cf       	rjmp	.-4      	; 0x21e <EEPROM_Read>
		ldi		r18,0x00		; Set up address (r18:r17) in EEPROM address register
 222:	20 e0       	ldi	r18, 0x00	; 0
		ldi		r17,0x05
 224:	15 e0       	ldi	r17, 0x05	; 5
		ldi		r16,0x00   
 226:	00 e0       	ldi	r16, 0x00	; 0
		out     EEARH, r18   
 228:	22 bd       	out	0x22, r18	; 34
		out     EEARL, r17		   
 22a:	11 bd       	out	0x21, r17	; 33
		sbi     EECR,EERE		; Start eeprom read by writing EERE
 22c:	f8 9a       	sbi	0x1f, 0	; 31
		in      r16,EEDR		; Read data from Data Register
 22e:	00 b5       	in	r16, 0x20	; 32
		sts		ASCII,r16  
 230:	00 93 d2 01 	sts	0x01D2, r16	; 0x8001d2 <ASCII>
		ret
 234:	08 95       	ret

00000236 <UART_Puts>:

char volts[5];					//string buffer for ADC output
int Acc;						//Accumulator for ADC use

void UART_Puts(const char *str)	//Display a string in the PC Terminal Program
{
 236:	cf 93       	push	r28
 238:	df 93       	push	r29
 23a:	ec 01       	movw	r28, r24
	while (*str)
 23c:	98 81       	ld	r25, Y
 23e:	99 23       	and	r25, r25
 240:	41 f0       	breq	.+16     	; 0x252 <UART_Puts+0x1c>
 242:	21 96       	adiw	r28, 0x01	; 1
	{
		ASCII = *str++;
 244:	90 93 d2 01 	sts	0x01D2, r25	; 0x8001d2 <ASCII>
		UART_Put();
 248:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <UART_Put>
char volts[5];					//string buffer for ADC output
int Acc;						//Accumulator for ADC use

void UART_Puts(const char *str)	//Display a string in the PC Terminal Program
{
	while (*str)
 24c:	99 91       	ld	r25, Y+
 24e:	91 11       	cpse	r25, r1
 250:	f9 cf       	rjmp	.-14     	; 0x244 <UART_Puts+0xe>
	{
		ASCII = *str++;
		UART_Put();
	}
}
 252:	df 91       	pop	r29
 254:	cf 91       	pop	r28
 256:	08 95       	ret

00000258 <LCD_Puts>:

void LCD_Puts(const char *str)	//Display a string on the LCD Module
{
 258:	cf 93       	push	r28
 25a:	df 93       	push	r29
 25c:	ec 01       	movw	r28, r24
	while (*str)
 25e:	98 81       	ld	r25, Y
 260:	99 23       	and	r25, r25
 262:	41 f0       	breq	.+16     	; 0x274 <LCD_Puts+0x1c>
 264:	21 96       	adiw	r28, 0x01	; 1
	{
		DATA = *str++;
 266:	90 93 d0 01 	sts	0x01D0, r25	; 0x8001d0 <__data_end>
		LCD_Write_Data();
 26a:	0e 94 b3 00 	call	0x166	; 0x166 <LCD_Write_Data>
	}
}

void LCD_Puts(const char *str)	//Display a string on the LCD Module
{
	while (*str)
 26e:	99 91       	ld	r25, Y+
 270:	91 11       	cpse	r25, r1
 272:	f9 cf       	rjmp	.-14     	; 0x266 <LCD_Puts+0xe>
	{
		DATA = *str++;
		LCD_Write_Data();
	}
}
 274:	df 91       	pop	r29
 276:	cf 91       	pop	r28
 278:	08 95       	ret

0000027a <Banner>:


void Banner(void)				//Display Tiny OS Banner on Terminal
{
	UART_Puts(MS1);
 27a:	82 eb       	ldi	r24, 0xB2	; 178
 27c:	91 e0       	ldi	r25, 0x01	; 1
 27e:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	UART_Puts(MS2);
 282:	8b e7       	ldi	r24, 0x7B	; 123
 284:	91 e0       	ldi	r25, 0x01	; 1
 286:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	UART_Puts(MS4);
 28a:	80 e5       	ldi	r24, 0x50	; 80
 28c:	91 e0       	ldi	r25, 0x01	; 1
 28e:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
 292:	08 95       	ret

00000294 <HELP>:
}

void HELP(void)						//Display available Tiny OS Commands on Terminal
{
	UART_Puts(MS3);
 294:	8a e5       	ldi	r24, 0x5A	; 90
 296:	91 e0       	ldi	r25, 0x01	; 1
 298:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
 29c:	08 95       	ret

0000029e <LCD>:
}

void LCD(void)						//Lite LCD demo
{
	DATA = 0x34;					//Student Comment Here
 29e:	84 e3       	ldi	r24, 0x34	; 52
 2a0:	80 93 d0 01 	sts	0x01D0, r24	; 0x8001d0 <__data_end>
	LCD_Write_Command();
 2a4:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x08;					//Student Comment Here
 2a8:	88 e0       	ldi	r24, 0x08	; 8
 2aa:	80 93 d0 01 	sts	0x01D0, r24	; 0x8001d0 <__data_end>
	LCD_Write_Command();
 2ae:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x02;					//Student Comment Here
 2b2:	82 e0       	ldi	r24, 0x02	; 2
 2b4:	80 93 d0 01 	sts	0x01D0, r24	; 0x8001d0 <__data_end>
	LCD_Write_Command();
 2b8:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x06;					//Student Comment Here
 2bc:	86 e0       	ldi	r24, 0x06	; 6
 2be:	80 93 d0 01 	sts	0x01D0, r24	; 0x8001d0 <__data_end>
	LCD_Write_Command();
 2c2:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x0f;					//Student Comment Here
 2c6:	8f e0       	ldi	r24, 0x0F	; 15
 2c8:	80 93 d0 01 	sts	0x01D0, r24	; 0x8001d0 <__data_end>
	LCD_Write_Command();
 2cc:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	LCD_Puts("Hello ECE412!");
 2d0:	80 e0       	ldi	r24, 0x00	; 0
 2d2:	91 e0       	ldi	r25, 0x01	; 1
 2d4:	0e 94 2c 01 	call	0x258	; 0x258 <LCD_Puts>
 2d8:	08 95       	ret

000002da <ADC>:
	always be able to return to command line.
	*/
}

void ADC(void)						//Lite Demo of the Analog to Digital Converter
{
 2da:	cf 93       	push	r28
 2dc:	df 93       	push	r29
	volts[0x1]='.';
 2de:	c3 ed       	ldi	r28, 0xD3	; 211
 2e0:	d1 e0       	ldi	r29, 0x01	; 1
 2e2:	8e e2       	ldi	r24, 0x2E	; 46
 2e4:	89 83       	std	Y+1, r24	; 0x01
	volts[0x3]=' ';
 2e6:	80 e2       	ldi	r24, 0x20	; 32
 2e8:	8b 83       	std	Y+3, r24	; 0x03
	volts[0x4]= 0;
 2ea:	1c 82       	std	Y+4, r1	; 0x04
	ADC_Get();
 2ec:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <ADC_Get>
	Acc = (((int)HADC) * 0x100 + (int)(LADC))*0xA;
 2f0:	20 91 d1 01 	lds	r18, 0x01D1	; 0x8001d1 <HADC>
 2f4:	30 e0       	ldi	r19, 0x00	; 0
 2f6:	32 2f       	mov	r19, r18
 2f8:	22 27       	eor	r18, r18
 2fa:	80 91 d8 01 	lds	r24, 0x01D8	; 0x8001d8 <LADC>
 2fe:	28 0f       	add	r18, r24
 300:	31 1d       	adc	r19, r1
 302:	c9 01       	movw	r24, r18
 304:	88 0f       	add	r24, r24
 306:	99 1f       	adc	r25, r25
 308:	22 0f       	add	r18, r18
 30a:	33 1f       	adc	r19, r19
 30c:	22 0f       	add	r18, r18
 30e:	33 1f       	adc	r19, r19
 310:	22 0f       	add	r18, r18
 312:	33 1f       	adc	r19, r19
 314:	82 0f       	add	r24, r18
 316:	93 1f       	adc	r25, r19
	volts[0x0] = 48 + (Acc / 0x7FE);
 318:	ee ef       	ldi	r30, 0xFE	; 254
 31a:	f7 e0       	ldi	r31, 0x07	; 7
 31c:	bf 01       	movw	r22, r30
 31e:	0e 94 06 02 	call	0x40c	; 0x40c <__divmodhi4>
 322:	26 2f       	mov	r18, r22
 324:	30 e3       	ldi	r19, 0x30	; 48
 326:	36 0f       	add	r19, r22
 328:	38 83       	st	Y, r19
	Acc = Acc % 0x7FE;
	volts[0x2] = ((Acc *0xA) / 0x7FE) + 48;
 32a:	ac 01       	movw	r20, r24
 32c:	44 0f       	add	r20, r20
 32e:	55 1f       	adc	r21, r21
 330:	88 0f       	add	r24, r24
 332:	99 1f       	adc	r25, r25
 334:	88 0f       	add	r24, r24
 336:	99 1f       	adc	r25, r25
 338:	88 0f       	add	r24, r24
 33a:	99 1f       	adc	r25, r25
 33c:	84 0f       	add	r24, r20
 33e:	95 1f       	adc	r25, r21
 340:	bf 01       	movw	r22, r30
 342:	0e 94 06 02 	call	0x40c	; 0x40c <__divmodhi4>
 346:	30 e3       	ldi	r19, 0x30	; 48
 348:	36 0f       	add	r19, r22
 34a:	3a 83       	std	Y+2, r19	; 0x02
	Acc = (Acc * 0xA) % 0x7FE;
 34c:	90 93 da 01 	sts	0x01DA, r25	; 0x8001da <Acc+0x1>
 350:	80 93 d9 01 	sts	0x01D9, r24	; 0x8001d9 <Acc>
	if (Acc >= 0x3FF) volts[0x2]++;
 354:	8f 3f       	cpi	r24, 0xFF	; 255
 356:	93 40       	sbci	r25, 0x03	; 3
 358:	1c f0       	brlt	.+6      	; 0x360 <ADC+0x86>
 35a:	6f 5c       	subi	r22, 0xCF	; 207
 35c:	60 93 d5 01 	sts	0x01D5, r22	; 0x8001d5 <volts+0x2>
	if (volts[0x2] == 58)
 360:	80 91 d5 01 	lds	r24, 0x01D5	; 0x8001d5 <volts+0x2>
 364:	8a 33       	cpi	r24, 0x3A	; 58
 366:	31 f4       	brne	.+12     	; 0x374 <ADC+0x9a>
	{
		volts[0x2] = 48;
 368:	e3 ed       	ldi	r30, 0xD3	; 211
 36a:	f1 e0       	ldi	r31, 0x01	; 1
 36c:	80 e3       	ldi	r24, 0x30	; 48
 36e:	82 83       	std	Z+2, r24	; 0x02
		volts[0x0]++;
 370:	2f 5c       	subi	r18, 0xCF	; 207
 372:	20 83       	st	Z, r18
	}
	UART_Puts(volts);
 374:	83 ed       	ldi	r24, 0xD3	; 211
 376:	91 e0       	ldi	r25, 0x01	; 1
 378:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	UART_Puts(MS6);
 37c:	8a e2       	ldi	r24, 0x2A	; 42
 37e:	91 e0       	ldi	r25, 0x01	; 1
 380:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		The potentiometer simulates a thermistor, its varying resistance simulates the
		varying resistance of a thermistor as it is heated and cooled. See the thermistor
		equations in the lab 3 folder. User must always be able to return to command line.
	*/
	
}
 384:	df 91       	pop	r29
 386:	cf 91       	pop	r28
 388:	08 95       	ret

0000038a <EEPROM>:

void EEPROM(void)
{
	UART_Puts("\r\nEEPROM Write and Read.");
 38a:	8e e0       	ldi	r24, 0x0E	; 14
 38c:	91 e0       	ldi	r25, 0x01	; 1
 38e:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	during run-time via the command line and the same byte of data can be read back and verified after the power to
	the Xplained Mini board has been cycled. Ask the user to enter a valid EEPROM address and an
	8-bit data value. Utilize the following two given Assembly based drivers to communicate with the EEPROM. You
	may modify the EEPROM drivers as needed. User must be able to always return to command line.
	*/
	UART_Puts("\r\n");
 392:	87 e2       	ldi	r24, 0x27	; 39
 394:	91 e0       	ldi	r25, 0x01	; 1
 396:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	EEPROM_Write();
 39a:	0e 94 04 01 	call	0x208	; 0x208 <EEPROM_Write>
	UART_Puts("\r\n");
 39e:	87 e2       	ldi	r24, 0x27	; 39
 3a0:	91 e0       	ldi	r25, 0x01	; 1
 3a2:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	EEPROM_Read();
 3a6:	0e 94 0f 01 	call	0x21e	; 0x21e <EEPROM_Read>
	UART_Put();
 3aa:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <UART_Put>
	UART_Puts("\r\n");
 3ae:	87 e2       	ldi	r24, 0x27	; 39
 3b0:	91 e0       	ldi	r25, 0x01	; 1
 3b2:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
 3b6:	08 95       	ret

000003b8 <Command>:
}


void Command(void)					//command interpreter
{
	UART_Puts(MS3);
 3b8:	8a e5       	ldi	r24, 0x5A	; 90
 3ba:	91 e0       	ldi	r25, 0x01	; 1
 3bc:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	ASCII = '\0';						
 3c0:	10 92 d2 01 	sts	0x01D2, r1	; 0x8001d2 <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 3c4:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>

void Command(void)					//command interpreter
{
	UART_Puts(MS3);
	ASCII = '\0';						
	while (ASCII == '\0')
 3c8:	80 91 d2 01 	lds	r24, 0x01D2	; 0x8001d2 <ASCII>
 3cc:	88 23       	and	r24, r24
 3ce:	d1 f3       	breq	.-12     	; 0x3c4 <Command+0xc>
	{
		UART_Get();
	}
	switch (ASCII)
 3d0:	85 36       	cpi	r24, 0x65	; 101
 3d2:	59 f0       	breq	.+22     	; 0x3ea <Command+0x32>
 3d4:	8c 36       	cpi	r24, 0x6C	; 108
 3d6:	19 f0       	breq	.+6      	; 0x3de <Command+0x26>
 3d8:	81 36       	cpi	r24, 0x61	; 97
 3da:	51 f4       	brne	.+20     	; 0x3f0 <Command+0x38>
 3dc:	03 c0       	rjmp	.+6      	; 0x3e4 <Command+0x2c>
	{
		case 'L' | 'l': LCD();
 3de:	0e 94 4f 01 	call	0x29e	; 0x29e <LCD>
		break;
 3e2:	08 95       	ret
		case 'A' | 'a': ADC();
 3e4:	0e 94 6d 01 	call	0x2da	; 0x2da <ADC>
		break;
 3e8:	08 95       	ret
		case 'E' | 'e': EEPROM();
 3ea:	0e 94 c5 01 	call	0x38a	; 0x38a <EEPROM>
		break;
 3ee:	08 95       	ret
		default:
		UART_Puts(MS5);
 3f0:	81 e3       	ldi	r24, 0x31	; 49
 3f2:	91 e0       	ldi	r25, 0x01	; 1
 3f4:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		HELP();
 3f8:	0e 94 4a 01 	call	0x294	; 0x294 <HELP>
 3fc:	08 95       	ret

000003fe <main>:
	}
}

int main(void)
{
	Mega328P_Init();
 3fe:	0e 94 79 00 	call	0xf2	; 0xf2 <Mega328P_Init>
	Banner();
 402:	0e 94 3d 01 	call	0x27a	; 0x27a <Banner>
	while (1)
	{
		Command();				//infinite command loop
 406:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <Command>
 40a:	fd cf       	rjmp	.-6      	; 0x406 <__LOCK_REGION_LENGTH__+0x6>

0000040c <__divmodhi4>:
 40c:	97 fb       	bst	r25, 7
 40e:	07 2e       	mov	r0, r23
 410:	16 f4       	brtc	.+4      	; 0x416 <__divmodhi4+0xa>
 412:	00 94       	com	r0
 414:	07 d0       	rcall	.+14     	; 0x424 <__divmodhi4_neg1>
 416:	77 fd       	sbrc	r23, 7
 418:	09 d0       	rcall	.+18     	; 0x42c <__divmodhi4_neg2>
 41a:	0e 94 1a 02 	call	0x434	; 0x434 <__udivmodhi4>
 41e:	07 fc       	sbrc	r0, 7
 420:	05 d0       	rcall	.+10     	; 0x42c <__divmodhi4_neg2>
 422:	3e f4       	brtc	.+14     	; 0x432 <__divmodhi4_exit>

00000424 <__divmodhi4_neg1>:
 424:	90 95       	com	r25
 426:	81 95       	neg	r24
 428:	9f 4f       	sbci	r25, 0xFF	; 255
 42a:	08 95       	ret

0000042c <__divmodhi4_neg2>:
 42c:	70 95       	com	r23
 42e:	61 95       	neg	r22
 430:	7f 4f       	sbci	r23, 0xFF	; 255

00000432 <__divmodhi4_exit>:
 432:	08 95       	ret

00000434 <__udivmodhi4>:
 434:	aa 1b       	sub	r26, r26
 436:	bb 1b       	sub	r27, r27
 438:	51 e1       	ldi	r21, 0x11	; 17
 43a:	07 c0       	rjmp	.+14     	; 0x44a <__udivmodhi4_ep>

0000043c <__udivmodhi4_loop>:
 43c:	aa 1f       	adc	r26, r26
 43e:	bb 1f       	adc	r27, r27
 440:	a6 17       	cp	r26, r22
 442:	b7 07       	cpc	r27, r23
 444:	10 f0       	brcs	.+4      	; 0x44a <__udivmodhi4_ep>
 446:	a6 1b       	sub	r26, r22
 448:	b7 0b       	sbc	r27, r23

0000044a <__udivmodhi4_ep>:
 44a:	88 1f       	adc	r24, r24
 44c:	99 1f       	adc	r25, r25
 44e:	5a 95       	dec	r21
 450:	a9 f7       	brne	.-22     	; 0x43c <__udivmodhi4_loop>
 452:	80 95       	com	r24
 454:	90 95       	com	r25
 456:	bc 01       	movw	r22, r24
 458:	cd 01       	movw	r24, r26
 45a:	08 95       	ret

0000045c <_exit>:
 45c:	f8 94       	cli

0000045e <__stop_program>:
 45e:	ff cf       	rjmp	.-2      	; 0x45e <__stop_program>
