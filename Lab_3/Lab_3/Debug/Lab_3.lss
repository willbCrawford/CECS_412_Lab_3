
Lab_3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000d8  00800100  000004a0  00000534  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000004a0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000b  008001d8  008001d8  0000060c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000060c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000063c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000098  00000000  00000000  00000680  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000101f  00000000  00000000  00000718  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000a56  00000000  00000000  00001737  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000007af  00000000  00000000  0000218d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000118  00000000  00000000  0000293c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000514  00000000  00000000  00002a54  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000240  00000000  00000000  00002f68  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000068  00000000  00000000  000031a8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 5a 00 	jmp	0xb4	; 0xb4 <__ctors_end>
   4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
   8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
   c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  10:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  14:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  18:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  1c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  20:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  24:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  28:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  2c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  30:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  34:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  38:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  3c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  40:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  44:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  48:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  4c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  50:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  54:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  58:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  5c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  60:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  64:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  68:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  6c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  70:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  74:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  78:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  7c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  80:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  84:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  88:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  8c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  90:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  94:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  98:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  9c:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a0:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a4:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  a8:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  ac:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>
  b0:	0c 94 77 00 	jmp	0xee	; 0xee <__bad_interrupt>

000000b4 <__ctors_end>:
  b4:	11 24       	eor	r1, r1
  b6:	1f be       	out	0x3f, r1	; 63
  b8:	cf ef       	ldi	r28, 0xFF	; 255
  ba:	d8 e0       	ldi	r29, 0x08	; 8
  bc:	de bf       	out	0x3e, r29	; 62
  be:	cd bf       	out	0x3d, r28	; 61

000000c0 <__do_copy_data>:
  c0:	11 e0       	ldi	r17, 0x01	; 1
  c2:	a0 e0       	ldi	r26, 0x00	; 0
  c4:	b1 e0       	ldi	r27, 0x01	; 1
  c6:	e0 ea       	ldi	r30, 0xA0	; 160
  c8:	f4 e0       	ldi	r31, 0x04	; 4
  ca:	02 c0       	rjmp	.+4      	; 0xd0 <UDR0+0xa>
  cc:	05 90       	lpm	r0, Z+
  ce:	0d 92       	st	X+, r0
  d0:	a8 3d       	cpi	r26, 0xD8	; 216
  d2:	b1 07       	cpc	r27, r17
  d4:	d9 f7       	brne	.-10     	; 0xcc <UDR0+0x6>

000000d6 <__do_clear_bss>:
  d6:	21 e0       	ldi	r18, 0x01	; 1
  d8:	a8 ed       	ldi	r26, 0xD8	; 216
  da:	b1 e0       	ldi	r27, 0x01	; 1
  dc:	01 c0       	rjmp	.+2      	; 0xe0 <.do_clear_bss_start>

000000de <.do_clear_bss_loop>:
  de:	1d 92       	st	X+, r1

000000e0 <.do_clear_bss_start>:
  e0:	a3 3e       	cpi	r26, 0xE3	; 227
  e2:	b2 07       	cpc	r27, r18
  e4:	e1 f7       	brne	.-8      	; 0xde <.do_clear_bss_loop>
  e6:	0e 94 1f 02 	call	0x43e	; 0x43e <main>
  ea:	0c 94 4e 02 	jmp	0x49c	; 0x49c <_exit>

000000ee <__bad_interrupt>:
  ee:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000f2 <Mega328P_Init>:
		;Begin here Nathan B.

.section ".text"			//equivalent to CSEG 
.global Mega328P_Init
Mega328P_Init:
		ldi	r16,0x07		;PB0(R*W),PB1(RS),PB2(E) as fixed outputs
  f2:	07 e0       	ldi	r16, 0x07	; 7
		out	DDRB,r16		//student comment here
  f4:	04 b9       	out	0x04, r16	; 4
		ldi	r16,0			//student comment here
  f6:	00 e0       	ldi	r16, 0x00	; 0
		out	PORTB,r16		//student comment here
  f8:	05 b9       	out	0x05, r16	; 5
		out	U2X0,r16		;initialize UART, 8bits, no parity, 1 stop, 9600
  fa:	01 b9       	out	0x01, r16	; 1
		ldi	r17,0x0			//student comment here
  fc:	10 e0       	ldi	r17, 0x00	; 0
		ldi	r16,0x67		//student comment here
  fe:	07 e6       	ldi	r16, 0x67	; 103
		sts	UBRR0H,r17		//student comment here
 100:	10 93 c5 00 	sts	0x00C5, r17	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
		sts	UBRR0L,r16		//student comment here
 104:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
		ldi	r16,24			//student comment here
 108:	08 e1       	ldi	r16, 0x18	; 24
		sts	UCSR0B,r16		//student comment here
 10a:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
		ldi	r16,6			//student comment here
 10e:	06 e0       	ldi	r16, 0x06	; 6
		sts	UCSR0C,r16		//student comment here
 110:	00 93 c2 00 	sts	0x00C2, r16	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
		ldi r16,0x87		//initialize ADC
 114:	07 e8       	ldi	r16, 0x87	; 135
		sts	ADCSRA,r16		//student comment here
 116:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		ldi r16,0x40		//student comment here
 11a:	00 e4       	ldi	r16, 0x40	; 64
		sts ADMUX,r16		//student comment here
 11c:	00 93 7c 00 	sts	0x007C, r16	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
		ldi r16,0			//student comment here
 120:	00 e0       	ldi	r16, 0x00	; 0
		sts ADCSRB,r16		//student comment here
 122:	00 93 7b 00 	sts	0x007B, r16	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
		ldi r16,0xFE		//student comment here
 126:	0e ef       	ldi	r16, 0xFE	; 254
		sts DIDR0,r16		//student comment here
 128:	00 93 7e 00 	sts	0x007E, r16	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
		ldi r16,0xFF		//student comment here
 12c:	0f ef       	ldi	r16, 0xFF	; 255
		sts DIDR1,r16		//student comment here
 12e:	00 93 7f 00 	sts	0x007F, r16	; 0x80007f <__TEXT_REGION_LENGTH__+0x7e007f>
		ret					//student comment here
 132:	08 95       	ret

00000134 <LCD_Write_Command>:
	
.global LCD_Write_Command
LCD_Write_Command:
	call	UART_Off		//student comment here
 134:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>
	ldi		r16,0xFF		;PD0 - PD7 as outputs
 138:	0f ef       	ldi	r16, 0xFF	; 255
	out		DDRD,r16		//student comment here
 13a:	0a b9       	out	0x0a, r16	; 10
	lds		r16,DATA		//student comment here
 13c:	00 91 d8 01 	lds	r16, 0x01D8	; 0x8001d8 <__data_end>
	out		PORTD,r16		//student comment here
 140:	0b b9       	out	0x0b, r16	; 11
	ldi		r16,4			//student comment here
 142:	04 e0       	ldi	r16, 0x04	; 4
	out		PORTB,r16		//student comment here
 144:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 146:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
	ldi		r16,0			//student comment here
 14a:	00 e0       	ldi	r16, 0x00	; 0
	out		PORTB,r16		//student comment here
 14c:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 14e:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
	call	UART_On			//student comment here
 152:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>
	ret						//student comment here
 156:	08 95       	ret

00000158 <LCD_Delay>:

	;Begin here, Laith

LCD_Delay:
	ldi		r16,0xFA		//student comment here
 158:	0a ef       	ldi	r16, 0xFA	; 250

0000015a <D0>:
D0:	ldi		r17,0xFF		//student comment here
 15a:	1f ef       	ldi	r17, 0xFF	; 255

0000015c <D1>:
D1:	dec		r17				//student comment here
 15c:	1a 95       	dec	r17
	brne	D1				//student comment here
 15e:	f1 f7       	brne	.-4      	; 0x15c <D1>
	dec		r16				//student comment here
 160:	0a 95       	dec	r16
	brne	D0				//student comment here
 162:	d9 f7       	brne	.-10     	; 0x15a <D0>
	ret						//student comment here
 164:	08 95       	ret

00000166 <LCD_Write_Data>:

.global LCD_Write_Data
LCD_Write_Data:
	call	UART_Off		//turn off communication
 166:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>
	ldi		r16,0xFF		//student comment here
 16a:	0f ef       	ldi	r16, 0xFF	; 255
	out		DDRD,r16		//student comment here
 16c:	0a b9       	out	0x0a, r16	; 10
	lds		r16,DATA		//student comment here
 16e:	00 91 d8 01 	lds	r16, 0x01D8	; 0x8001d8 <__data_end>
	out		PORTD,r16		//student comment here
 172:	0b b9       	out	0x0b, r16	; 11
	ldi		r16,6			//student comment here
 174:	06 e0       	ldi	r16, 0x06	; 6
	out		PORTB,r16		//student comment here
 176:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 178:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
	ldi		r16,0			//student comment here
 17c:	00 e0       	ldi	r16, 0x00	; 0
	out		PORTB,r16		//student comment here
 17e:	05 b9       	out	0x05, r16	; 5
	call	LCD_Delay		//student comment here
 180:	0e 94 ac 00 	call	0x158	; 0x158 <LCD_Delay>
	call	UART_On			//turn on the communication
 184:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>
	ret						//student comment here
 188:	08 95       	ret

0000018a <LCD_Read_Data>:

.global LCD_Read_Data
LCD_Read_Data:
	call	UART_Off		//student comment here
 18a:	0e 94 d7 00 	call	0x1ae	; 0x1ae <UART_Off>
	ldi		r16,0x00		//student comment here
 18e:	00 e0       	ldi	r16, 0x00	; 0
	out		DDRD,r16		//student comment here
 190:	0a b9       	out	0x0a, r16	; 10
	out		PORTB,4			//student comment here
 192:	45 b8       	out	0x05, r4	; 5
	in		r16,PORTD		//student comment here
 194:	0b b1       	in	r16, 0x0b	; 11
	sts		DATA,r16		//student comment here
 196:	00 93 d8 01 	sts	0x01D8, r16	; 0x8001d8 <__data_end>
	out		PORTB,0			//student comment here
 19a:	05 b8       	out	0x05, r0	; 5
	call	UART_On			//student comment here
 19c:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <UART_On>
	ret						//student comment here
 1a0:	08 95       	ret

000001a2 <UART_On>:

	;Begin here Nathan H.

.global UART_On
UART_On:
	ldi		r16,2				//student comment here
 1a2:	02 e0       	ldi	r16, 0x02	; 2
	out		DDRD,r16			//student comment here
 1a4:	0a b9       	out	0x0a, r16	; 10
	ldi		r16,24				//student comment here
 1a6:	08 e1       	ldi	r16, 0x18	; 24
	sts		UCSR0B,r16			//student comment here
 1a8:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	ret							//student comment here
 1ac:	08 95       	ret

000001ae <UART_Off>:

.global UART_Off
UART_Off:
	ldi	r16,0					//student comment here
 1ae:	00 e0       	ldi	r16, 0x00	; 0
	sts UCSR0B,r16				//student comment here
 1b0:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	ret							//student comment here
 1b4:	08 95       	ret

000001b6 <UART_Clear>:

.global UART_Clear
UART_Clear:
	lds		r16,UCSR0A			//student comment here
 1b6:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	r16,RXC0			//student comment here
 1ba:	07 ff       	sbrs	r16, 7
	ret							//student comment here
 1bc:	08 95       	ret
	lds		r16,UDR0			//student comment here
 1be:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	rjmp	UART_Clear			//student comment here
 1c2:	f9 cf       	rjmp	.-14     	; 0x1b6 <UART_Clear>

000001c4 <UART_Get>:

.global UART_Get
UART_Get:
	lds		r16,UCSR0A			//student comment here
 1c4:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	r16,RXC0			//student comment here
 1c8:	07 ff       	sbrs	r16, 7
	rjmp	UART_Get			//student comment here
 1ca:	fc cf       	rjmp	.-8      	; 0x1c4 <UART_Get>
	lds		r16,UDR0			//student comment here
 1cc:	00 91 c6 00 	lds	r16, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	sts		ASCII,r16			//student comment here
 1d0:	00 93 da 01 	sts	0x01DA, r16	; 0x8001da <ASCII>
	ret							//student comment here
 1d4:	08 95       	ret

000001d6 <UART_Put>:

.global UART_Put
UART_Put:
	lds		r17,UCSR0A			//student comment here
 1d6:	10 91 c0 00 	lds	r17, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	r17,UDRE0			//student comment here
 1da:	15 ff       	sbrs	r17, 5
	rjmp	UART_Put			//student comment here
 1dc:	fc cf       	rjmp	.-8      	; 0x1d6 <UART_Put>
	lds		r16,ASCII			//student comment here
 1de:	00 91 da 01 	lds	r16, 0x01DA	; 0x8001da <ASCII>
	sts		UDR0,r16			//student comment here
 1e2:	00 93 c6 00 	sts	0x00C6, r16	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
	ret							//student comment here
 1e6:	08 95       	ret

000001e8 <ADC_Get>:

	;Begin here, Dhan

.global ADC_Get
ADC_Get:
		ldi		r16,0xC7			//student comment here
 1e8:	07 ec       	ldi	r16, 0xC7	; 199
		sts		ADCSRA,r16			//student comment here
 1ea:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>

000001ee <A2V1>:
A2V1:	lds		r16,ADCSRA			//student comment here
 1ee:	00 91 7a 00 	lds	r16, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		sbrc	r16,ADSC			//student comment here
 1f2:	06 fd       	sbrc	r16, 6
		rjmp 	A2V1				//student comment here
 1f4:	fc cf       	rjmp	.-8      	; 0x1ee <A2V1>
		lds		r16,ADCL			//student comment here
 1f6:	00 91 78 00 	lds	r16, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
		sts		LADC,r16			//student comment here
 1fa:	00 93 e0 01 	sts	0x01E0, r16	; 0x8001e0 <LADC>
		lds		r16,ADCH			//student comment here
 1fe:	00 91 79 00 	lds	r16, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
		sts		HADC,r16			//student comment here
 202:	00 93 d9 01 	sts	0x01D9, r16	; 0x8001d9 <HADC>
		ret							//student comment here
 206:	08 95       	ret

00000208 <EEPROM_Write>:

.global EEPROM_Write
EEPROM_Write:      
		sbic    EECR,EEPE
 208:	f9 99       	sbic	0x1f, 1	; 31
		rjmp    EEPROM_Write		; Wait for completion of previous write
 20a:	fe cf       	rjmp	.-4      	; 0x208 <EEPROM_Write>
		ldi		r18,0x00			; Set up address (r18:r17) in address register
 20c:	20 e0       	ldi	r18, 0x00	; 0
		ldi		r17,0x05 
 20e:	15 e0       	ldi	r17, 0x05	; 5
		ldi		r16,'F'				; Set up data in r16    
 210:	06 e4       	ldi	r16, 0x46	; 70
		out     EEARH, r18      
 212:	22 bd       	out	0x22, r18	; 34
		out     EEARL, r17			      
 214:	11 bd       	out	0x21, r17	; 33
		out     EEDR,r16			; Write data (r16) to Data Register  
 216:	00 bd       	out	0x20, r16	; 32
		sbi     EECR,EEMPE			; Write logical one to EEMPE
 218:	fa 9a       	sbi	0x1f, 2	; 31
		sbi     EECR,EEPE			; Start eeprom write by setting EEPE
 21a:	f9 9a       	sbi	0x1f, 1	; 31
		ret 
 21c:	08 95       	ret

0000021e <EEPROM_Read>:

.global EEPROM_Read
EEPROM_Read:					    
		sbic    EECR,EEPE    
 21e:	f9 99       	sbic	0x1f, 1	; 31
		rjmp    EEPROM_Read		; Wait for completion of previous write
 220:	fe cf       	rjmp	.-4      	; 0x21e <EEPROM_Read>
		ldi		r18,0x00		; Set up address (r18:r17) in EEPROM address register
 222:	20 e0       	ldi	r18, 0x00	; 0
		ldi		r17,0x05
 224:	15 e0       	ldi	r17, 0x05	; 5
		ldi		r16,0x00   
 226:	00 e0       	ldi	r16, 0x00	; 0
		out     EEARH, r18   
 228:	22 bd       	out	0x22, r18	; 34
		out     EEARL, r17		   
 22a:	11 bd       	out	0x21, r17	; 33
		sbi     EECR,EERE		; Start eeprom read by writing EERE
 22c:	f8 9a       	sbi	0x1f, 0	; 31
		in      r16,EEDR		; Read data from Data Register
 22e:	00 b5       	in	r16, 0x20	; 32
		sts		ASCII,r16  
 230:	00 93 da 01 	sts	0x01DA, r16	; 0x8001da <ASCII>
		ret
 234:	08 95       	ret

00000236 <UART_Puts>:
}

void LCD_PutChar(const char str){
	DATA = str;
	
	LCD_Write_Data();
 236:	cf 93       	push	r28
 238:	df 93       	push	r29
 23a:	ec 01       	movw	r28, r24
 23c:	98 81       	ld	r25, Y
 23e:	99 23       	and	r25, r25
 240:	41 f0       	breq	.+16     	; 0x252 <UART_Puts+0x1c>
 242:	21 96       	adiw	r28, 0x01	; 1
 244:	90 93 da 01 	sts	0x01DA, r25	; 0x8001da <ASCII>
 248:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <UART_Put>
 24c:	99 91       	ld	r25, Y+
 24e:	91 11       	cpse	r25, r1
 250:	f9 cf       	rjmp	.-14     	; 0x244 <UART_Puts+0xe>
 252:	df 91       	pop	r29
 254:	cf 91       	pop	r28
 256:	08 95       	ret

00000258 <Banner>:
}


void Banner(void)				//Display Tiny OS Banner on Terminal
{
	UART_Puts(MS1);
 258:	8b eb       	ldi	r24, 0xBB	; 187
 25a:	91 e0       	ldi	r25, 0x01	; 1
 25c:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	UART_Puts(MS2);
 260:	84 e8       	ldi	r24, 0x84	; 132
 262:	91 e0       	ldi	r25, 0x01	; 1
 264:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	UART_Puts(MS4);
 268:	89 e5       	ldi	r24, 0x59	; 89
 26a:	91 e0       	ldi	r25, 0x01	; 1
 26c:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
 270:	08 95       	ret

00000272 <HELP>:
}

void HELP(void)						//Display available Tiny OS Commands on Terminal
{
	UART_Puts(MS3);
 272:	83 e6       	ldi	r24, 0x63	; 99
 274:	91 e0       	ldi	r25, 0x01	; 1
 276:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
 27a:	08 95       	ret

0000027c <ScrollFromRight>:
	}
	
	ScrollFromRight(str);
}

void ScrollFromRight(char* str){
 27c:	cf 93       	push	r28
 27e:	df 93       	push	r29
 280:	ec 01       	movw	r28, r24
	
	char char_to_put_on_LCD;
	
	while (*str){
 282:	88 81       	ld	r24, Y
 284:	88 23       	and	r24, r24
 286:	39 f0       	breq	.+14     	; 0x296 <ScrollFromRight+0x1a>
		LCD_Write_Data();
	}
}

void LCD_PutChar(const char str){
	DATA = str;
 288:	80 93 d8 01 	sts	0x01D8, r24	; 0x8001d8 <__data_end>
	
	LCD_Write_Data();
 28c:	0e 94 b3 00 	call	0x166	; 0x166 <LCD_Write_Data>

void ScrollFromRight(char* str){
	
	char char_to_put_on_LCD;
	
	while (*str){
 290:	8a 91       	ld	r24, -Y
 292:	81 11       	cpse	r24, r1
 294:	f9 cf       	rjmp	.-14     	; 0x288 <ScrollFromRight+0xc>
		char_to_put_on_LCD = *str--;
		
		LCD_PutChar(char_to_put_on_LCD);
		
	}
}
 296:	df 91       	pop	r29
 298:	cf 91       	pop	r28
 29a:	08 95       	ret

0000029c <ScrollFromLeft>:
		UART_Get();
		
	} while (ASCII == '\0');
}

void ScrollFromLeft(const char* str){
 29c:	0f 93       	push	r16
 29e:	1f 93       	push	r17
 2a0:	cf 93       	push	r28
 2a2:	df 93       	push	r29
 2a4:	8c 01       	movw	r16, r24
	
	char char_to_put_on_LCD;
	
	while (*str){
 2a6:	fc 01       	movw	r30, r24
 2a8:	80 81       	ld	r24, Z
 2aa:	88 23       	and	r24, r24
 2ac:	51 f0       	breq	.+20     	; 0x2c2 <ScrollFromLeft+0x26>
 2ae:	e8 01       	movw	r28, r16
 2b0:	21 96       	adiw	r28, 0x01	; 1
		
		char_to_put_on_LCD = *str++;
 2b2:	8e 01       	movw	r16, r28
		LCD_Write_Data();
	}
}

void LCD_PutChar(const char str){
	DATA = str;
 2b4:	80 93 d8 01 	sts	0x01D8, r24	; 0x8001d8 <__data_end>
	
	LCD_Write_Data();
 2b8:	0e 94 b3 00 	call	0x166	; 0x166 <LCD_Write_Data>

void ScrollFromLeft(const char* str){
	
	char char_to_put_on_LCD;
	
	while (*str){
 2bc:	89 91       	ld	r24, Y+
 2be:	81 11       	cpse	r24, r1
 2c0:	f8 cf       	rjmp	.-16     	; 0x2b2 <ScrollFromLeft+0x16>
		
		LCD_PutChar(char_to_put_on_LCD);
		
	}
	
	ScrollFromRight(str);
 2c2:	c8 01       	movw	r24, r16
 2c4:	0e 94 3e 01 	call	0x27c	; 0x27c <ScrollFromRight>
}
 2c8:	df 91       	pop	r29
 2ca:	cf 91       	pop	r28
 2cc:	1f 91       	pop	r17
 2ce:	0f 91       	pop	r16
 2d0:	08 95       	ret

000002d2 <LCD>:
	UART_Puts(MS3);
}

void LCD(void)						//Lite LCD demo
{
	DATA = 0x34;					//Student Comment Here
 2d2:	84 e3       	ldi	r24, 0x34	; 52
 2d4:	80 93 d8 01 	sts	0x01D8, r24	; 0x8001d8 <__data_end>
	LCD_Write_Command();
 2d8:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x08;					//Student Comment Here
 2dc:	88 e0       	ldi	r24, 0x08	; 8
 2de:	80 93 d8 01 	sts	0x01D8, r24	; 0x8001d8 <__data_end>
	LCD_Write_Command();
 2e2:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x02;					//Student Comment Here
 2e6:	82 e0       	ldi	r24, 0x02	; 2
 2e8:	80 93 d8 01 	sts	0x01D8, r24	; 0x8001d8 <__data_end>
	LCD_Write_Command();
 2ec:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x06;					//Student Comment Here
 2f0:	86 e0       	ldi	r24, 0x06	; 6
 2f2:	80 93 d8 01 	sts	0x01D8, r24	; 0x8001d8 <__data_end>
	LCD_Write_Command();
 2f6:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	DATA = 0x0f;					//Student Comment Here
 2fa:	8f e0       	ldi	r24, 0x0F	; 15
 2fc:	80 93 d8 01 	sts	0x01D8, r24	; 0x8001d8 <__data_end>
	LCD_Write_Command();
 300:	0e 94 9a 00 	call	0x134	; 0x134 <LCD_Write_Command>
	
	do 
	{
		ScrollFromLeft("We are Barely Passing!");
 304:	80 e0       	ldi	r24, 0x00	; 0
 306:	91 e0       	ldi	r25, 0x01	; 1
 308:	0e 94 4e 01 	call	0x29c	; 0x29c <ScrollFromLeft>
		your Team's name either vertically or horizontally. Any key press should stop
		the scrolling and return execution to the command line in Terminal. User must
		always be able to return to command line.
		*/
		
		UART_Get();
 30c:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>
		
	} while (ASCII == '\0');
 310:	80 91 da 01 	lds	r24, 0x01DA	; 0x8001da <ASCII>
 314:	88 23       	and	r24, r24
 316:	b1 f3       	breq	.-20     	; 0x304 <LCD+0x32>
}
 318:	08 95       	ret

0000031a <ADC>:
		
	}
}

void ADC(void)						//Lite Demo of the Analog to Digital Converter
{
 31a:	cf 93       	push	r28
 31c:	df 93       	push	r29
	volts[0x1]='.';
 31e:	cb ed       	ldi	r28, 0xDB	; 219
 320:	d1 e0       	ldi	r29, 0x01	; 1
 322:	8e e2       	ldi	r24, 0x2E	; 46
 324:	89 83       	std	Y+1, r24	; 0x01
	volts[0x3]=' ';
 326:	80 e2       	ldi	r24, 0x20	; 32
 328:	8b 83       	std	Y+3, r24	; 0x03
	volts[0x4]= 0;
 32a:	1c 82       	std	Y+4, r1	; 0x04
	ADC_Get();
 32c:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <ADC_Get>
	Acc = (((int)HADC) * 0x100 + (int)(LADC))*0xA;
 330:	20 91 d9 01 	lds	r18, 0x01D9	; 0x8001d9 <HADC>
 334:	30 e0       	ldi	r19, 0x00	; 0
 336:	32 2f       	mov	r19, r18
 338:	22 27       	eor	r18, r18
 33a:	80 91 e0 01 	lds	r24, 0x01E0	; 0x8001e0 <LADC>
 33e:	28 0f       	add	r18, r24
 340:	31 1d       	adc	r19, r1
 342:	c9 01       	movw	r24, r18
 344:	88 0f       	add	r24, r24
 346:	99 1f       	adc	r25, r25
 348:	22 0f       	add	r18, r18
 34a:	33 1f       	adc	r19, r19
 34c:	22 0f       	add	r18, r18
 34e:	33 1f       	adc	r19, r19
 350:	22 0f       	add	r18, r18
 352:	33 1f       	adc	r19, r19
 354:	82 0f       	add	r24, r18
 356:	93 1f       	adc	r25, r19
	volts[0x0] = 48 + (Acc / 0x7FE);
 358:	ee ef       	ldi	r30, 0xFE	; 254
 35a:	f7 e0       	ldi	r31, 0x07	; 7
 35c:	bf 01       	movw	r22, r30
 35e:	0e 94 26 02 	call	0x44c	; 0x44c <__divmodhi4>
 362:	26 2f       	mov	r18, r22
 364:	30 e3       	ldi	r19, 0x30	; 48
 366:	36 0f       	add	r19, r22
 368:	38 83       	st	Y, r19
	Acc = Acc % 0x7FE;
	volts[0x2] = ((Acc *0xA) / 0x7FE) + 48;
 36a:	ac 01       	movw	r20, r24
 36c:	44 0f       	add	r20, r20
 36e:	55 1f       	adc	r21, r21
 370:	88 0f       	add	r24, r24
 372:	99 1f       	adc	r25, r25
 374:	88 0f       	add	r24, r24
 376:	99 1f       	adc	r25, r25
 378:	88 0f       	add	r24, r24
 37a:	99 1f       	adc	r25, r25
 37c:	84 0f       	add	r24, r20
 37e:	95 1f       	adc	r25, r21
 380:	bf 01       	movw	r22, r30
 382:	0e 94 26 02 	call	0x44c	; 0x44c <__divmodhi4>
 386:	30 e3       	ldi	r19, 0x30	; 48
 388:	36 0f       	add	r19, r22
 38a:	3a 83       	std	Y+2, r19	; 0x02
	Acc = (Acc * 0xA) % 0x7FE;
 38c:	90 93 e2 01 	sts	0x01E2, r25	; 0x8001e2 <Acc+0x1>
 390:	80 93 e1 01 	sts	0x01E1, r24	; 0x8001e1 <Acc>
	if (Acc >= 0x3FF) volts[0x2]++;
 394:	8f 3f       	cpi	r24, 0xFF	; 255
 396:	93 40       	sbci	r25, 0x03	; 3
 398:	1c f0       	brlt	.+6      	; 0x3a0 <ADC+0x86>
 39a:	6f 5c       	subi	r22, 0xCF	; 207
 39c:	60 93 dd 01 	sts	0x01DD, r22	; 0x8001dd <volts+0x2>
	if (volts[0x2] == 58)
 3a0:	80 91 dd 01 	lds	r24, 0x01DD	; 0x8001dd <volts+0x2>
 3a4:	8a 33       	cpi	r24, 0x3A	; 58
 3a6:	31 f4       	brne	.+12     	; 0x3b4 <ADC+0x9a>
	{
		volts[0x2] = 48;
 3a8:	eb ed       	ldi	r30, 0xDB	; 219
 3aa:	f1 e0       	ldi	r31, 0x01	; 1
 3ac:	80 e3       	ldi	r24, 0x30	; 48
 3ae:	82 83       	std	Z+2, r24	; 0x02
		volts[0x0]++;
 3b0:	2f 5c       	subi	r18, 0xCF	; 207
 3b2:	20 83       	st	Z, r18
	}
	UART_Puts(volts);
 3b4:	8b ed       	ldi	r24, 0xDB	; 219
 3b6:	91 e0       	ldi	r25, 0x01	; 1
 3b8:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	UART_Puts(MS6);
 3bc:	83 e3       	ldi	r24, 0x33	; 51
 3be:	91 e0       	ldi	r25, 0x01	; 1
 3c0:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		The potentiometer simulates a thermistor, its varying resistance simulates the
		varying resistance of a thermistor as it is heated and cooled. See the thermistor
		equations in the lab 3 folder. User must always be able to return to command line.
	*/
	
}
 3c4:	df 91       	pop	r29
 3c6:	cf 91       	pop	r28
 3c8:	08 95       	ret

000003ca <EEPROM>:

void EEPROM(void)
{
	UART_Puts("\r\nEEPROM Write and Read.");
 3ca:	87 e1       	ldi	r24, 0x17	; 23
 3cc:	91 e0       	ldi	r25, 0x01	; 1
 3ce:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	during run-time via the command line and the same byte of data can be read back and verified after the power to
	the Xplained Mini board has been cycled. Ask the user to enter a valid EEPROM address and an
	8-bit data value. Utilize the following two given Assembly based drivers to communicate with the EEPROM. You
	may modify the EEPROM drivers as needed. User must be able to always return to command line.
	*/
	UART_Puts("\r\n");
 3d2:	80 e3       	ldi	r24, 0x30	; 48
 3d4:	91 e0       	ldi	r25, 0x01	; 1
 3d6:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	EEPROM_Write();
 3da:	0e 94 04 01 	call	0x208	; 0x208 <EEPROM_Write>
	UART_Puts("\r\n");
 3de:	80 e3       	ldi	r24, 0x30	; 48
 3e0:	91 e0       	ldi	r25, 0x01	; 1
 3e2:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	EEPROM_Read();
 3e6:	0e 94 0f 01 	call	0x21e	; 0x21e <EEPROM_Read>
	UART_Put();
 3ea:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <UART_Put>
	UART_Puts("\r\n");
 3ee:	80 e3       	ldi	r24, 0x30	; 48
 3f0:	91 e0       	ldi	r25, 0x01	; 1
 3f2:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
 3f6:	08 95       	ret

000003f8 <Command>:
}


void Command(void)					//command interpreter
{
	UART_Puts(MS3);
 3f8:	83 e6       	ldi	r24, 0x63	; 99
 3fa:	91 e0       	ldi	r25, 0x01	; 1
 3fc:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
	ASCII = '\0';						
 400:	10 92 da 01 	sts	0x01DA, r1	; 0x8001da <ASCII>
	while (ASCII == '\0')
	{
		UART_Get();
 404:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <UART_Get>

void Command(void)					//command interpreter
{
	UART_Puts(MS3);
	ASCII = '\0';						
	while (ASCII == '\0')
 408:	80 91 da 01 	lds	r24, 0x01DA	; 0x8001da <ASCII>
 40c:	88 23       	and	r24, r24
 40e:	d1 f3       	breq	.-12     	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
	{
		UART_Get();
	}
	switch (ASCII)
 410:	85 36       	cpi	r24, 0x65	; 101
 412:	59 f0       	breq	.+22     	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
 414:	8c 36       	cpi	r24, 0x6C	; 108
 416:	19 f0       	breq	.+6      	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
 418:	81 36       	cpi	r24, 0x61	; 97
 41a:	51 f4       	brne	.+20     	; 0x430 <__LOCK_REGION_LENGTH__+0x30>
 41c:	03 c0       	rjmp	.+6      	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
	{
		case 'L' | 'l': LCD();
 41e:	0e 94 69 01 	call	0x2d2	; 0x2d2 <LCD>
		break;
 422:	08 95       	ret
		case 'A' | 'a': ADC();
 424:	0e 94 8d 01 	call	0x31a	; 0x31a <ADC>
		break;
 428:	08 95       	ret
		case 'E' | 'e': EEPROM();
 42a:	0e 94 e5 01 	call	0x3ca	; 0x3ca <EEPROM>
		break;
 42e:	08 95       	ret
		default:
		UART_Puts(MS5);
 430:	8a e3       	ldi	r24, 0x3A	; 58
 432:	91 e0       	ldi	r25, 0x01	; 1
 434:	0e 94 1b 01 	call	0x236	; 0x236 <UART_Puts>
		HELP();
 438:	0e 94 39 01 	call	0x272	; 0x272 <HELP>
 43c:	08 95       	ret

0000043e <main>:
	}
}

int main(void)
{
	Mega328P_Init();
 43e:	0e 94 79 00 	call	0xf2	; 0xf2 <Mega328P_Init>
	Banner();
 442:	0e 94 2c 01 	call	0x258	; 0x258 <Banner>
	while (1)
	{
		Command();				//infinite command loop
 446:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <Command>
 44a:	fd cf       	rjmp	.-6      	; 0x446 <main+0x8>

0000044c <__divmodhi4>:
 44c:	97 fb       	bst	r25, 7
 44e:	07 2e       	mov	r0, r23
 450:	16 f4       	brtc	.+4      	; 0x456 <__divmodhi4+0xa>
 452:	00 94       	com	r0
 454:	07 d0       	rcall	.+14     	; 0x464 <__divmodhi4_neg1>
 456:	77 fd       	sbrc	r23, 7
 458:	09 d0       	rcall	.+18     	; 0x46c <__divmodhi4_neg2>
 45a:	0e 94 3a 02 	call	0x474	; 0x474 <__udivmodhi4>
 45e:	07 fc       	sbrc	r0, 7
 460:	05 d0       	rcall	.+10     	; 0x46c <__divmodhi4_neg2>
 462:	3e f4       	brtc	.+14     	; 0x472 <__divmodhi4_exit>

00000464 <__divmodhi4_neg1>:
 464:	90 95       	com	r25
 466:	81 95       	neg	r24
 468:	9f 4f       	sbci	r25, 0xFF	; 255
 46a:	08 95       	ret

0000046c <__divmodhi4_neg2>:
 46c:	70 95       	com	r23
 46e:	61 95       	neg	r22
 470:	7f 4f       	sbci	r23, 0xFF	; 255

00000472 <__divmodhi4_exit>:
 472:	08 95       	ret

00000474 <__udivmodhi4>:
 474:	aa 1b       	sub	r26, r26
 476:	bb 1b       	sub	r27, r27
 478:	51 e1       	ldi	r21, 0x11	; 17
 47a:	07 c0       	rjmp	.+14     	; 0x48a <__udivmodhi4_ep>

0000047c <__udivmodhi4_loop>:
 47c:	aa 1f       	adc	r26, r26
 47e:	bb 1f       	adc	r27, r27
 480:	a6 17       	cp	r26, r22
 482:	b7 07       	cpc	r27, r23
 484:	10 f0       	brcs	.+4      	; 0x48a <__udivmodhi4_ep>
 486:	a6 1b       	sub	r26, r22
 488:	b7 0b       	sbc	r27, r23

0000048a <__udivmodhi4_ep>:
 48a:	88 1f       	adc	r24, r24
 48c:	99 1f       	adc	r25, r25
 48e:	5a 95       	dec	r21
 490:	a9 f7       	brne	.-22     	; 0x47c <__udivmodhi4_loop>
 492:	80 95       	com	r24
 494:	90 95       	com	r25
 496:	bc 01       	movw	r22, r24
 498:	cd 01       	movw	r24, r26
 49a:	08 95       	ret

0000049c <_exit>:
 49c:	f8 94       	cli

0000049e <__stop_program>:
 49e:	ff cf       	rjmp	.-2      	; 0x49e <__stop_program>
